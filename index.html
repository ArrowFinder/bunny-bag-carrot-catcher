<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bunny Bag ‚Äî Carrot Catcher</title>
    <!--
        Bunny Bag ‚Äî Carrot Catcher Game
        Version: 1.0.0
        Author: AI Assistant
        Description: Retro-style HTML5 Canvas arcade game
        
        Features:
        - 8-bit pixel art aesthetic
        - Progressive difficulty scaling
        - Multiple obstacle types with unique movement patterns
        - Power-up system with mystery boxes
        - Score-based progression
        - No external dependencies
    -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #eee;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            border: 4px solid #4a4a6a;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            background: #1a1a2e;
        }
        
        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            border-radius: 4px;
        }
        
        #crtOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: linear-gradient(transparent 50%, rgba(0, 255, 0, 0.03) 50%);
            background-size: 100% 4px;
            opacity: 0;
            transition: opacity 0.3s;
            border-radius: 4px;
        }
        
        #crtOverlay.active {
            opacity: 1;
        }
        
        .controls {
            position: absolute;
            bottom: -60px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 12px;
            color: #888;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 4px;
        }
        
        /* Touch Controls */
        .touch-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: none;
            flex-direction: column;
            gap: 10px;
        }
        
        .touch-controls.show {
            display: flex;
        }
        
        .touch-button {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            padding: 15px 20px;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
            min-width: 60px;
            text-align: center;
        }
        
        .touch-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        
        .touch-button:active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.95);
        }
        
        .touch-row {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .touch-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 255, 0, 0.8);
            border: 2px solid #00ff00;
            border-radius: 8px;
            color: #000;
            font-size: 14px;
            font-weight: bold;
            padding: 10px 15px;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
        }
        
        .touch-toggle:hover {
            background: rgba(0, 255, 0, 1);
            transform: scale(1.05);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff00;
            font-size: 18px;
            font-family: 'Courier New', monospace;
        }

        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            text-align: center;
            max-width: 300px;
        }

        @media (max-width: 900px) {
            body {
                padding: 10px;
            }
            
            #gameContainer {
                max-width: 100%;
                max-height: 100vh;
            }
            
            #gameCanvas {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="crtOverlay"></div>
        <div class="controls">
            ‚Üê ‚Üí or A D Move | ‚Üë or W S Jump | Space: Start/Pause | M: Mute | C: Toggle CRT
        </div>
        
        <!-- Touch Controls Toggle -->
        <button class="touch-toggle" id="touchToggle">üì± Touch</button>
        
        <!-- Touch Controls -->
        <div class="touch-controls" id="touchControls">
            <div class="touch-row">
                <button class="touch-button" id="leftBtn">‚Üê</button>
                <button class="touch-button" id="jumpBtn">‚Üë</button>
                <button class="touch-button" id="rightBtn">‚Üí</button>
            </div>
        </div>
        
        <div id="loading" class="loading" style="display: none;">
            Loading Game...
        </div>
        <div id="error" class="error" style="display: none;">
            Failed to load game. Please refresh the page.
        </div>
    </div>
    
    <script>
        /**
         * BUNNY BAG GAME - INLINE IMPLEMENTATION
         * Complete game implementation to avoid CORS issues when opening directly
         */
        console.log('Loading Bunny Bag Game...');
        
        /**
         * GAME CONSTANTS
         * Core game dimensions and physics parameters
         */
        const GAME_WIDTH = 800;                    // Canvas width in pixels
        const GAME_HEIGHT = 600;                   // Canvas height in pixels
        const PLAYER_WIDTH = 58;                   // Player character width
        const PLAYER_HEIGHT = 58;                  // Player character height
        const CARROT_SIZE = 16;                    // Carrot sprite size (square)
        const BAG_WIDTH = 72;                      // Sack width (larger than player)
        const BAG_HEIGHT = 36;                     // Sack height
        const GROUND_Y = GAME_HEIGHT - 20;         // Ground level Y coordinate
        const JUMP_POWER = 14;                     // Initial jump velocity
        const GRAVITY = 0.5;                       // Gravity acceleration per frame
        const OBSTACLE_WIDTH = 24;                 // Obstacle hitbox width
        const OBSTACLE_HEIGHT = 32;                // Obstacle hitbox height
        const MYSTERY_BOX_SIZE = 50;               // Mystery box dimensions
        const MYSTERY_BOX_HEIGHT = 400;            // Fixed spawn height for mystery boxes

        /**
         * COLOR PALETTE
         * 8-bit retro color scheme for consistent visual style
         */
        const COLORS = {
            background: '#1a1a2e',      // Dark blue background
            player: '#ff6b6b',          // Light red for bunny
            carrot: '#ffa500',          // Orange for carrots
            bag: '#8b4513',             // Brown for sack
            text: '#ffffff',            // White text
            ui: '#00ff00',              // Green UI elements
            shadow: '#000000',          // Black shadows
            ground: '#4a4a6a',          // Gray ground
            obstacle: '#8B4513',        // Brown obstacles
            obstacleTop: '#A0522D',     // Lighter brown for obstacle details
            bunnyPink: '#ffb6c1',       // Pink for bunny details
            bunnyNose: '#ff69b4',       // Hot pink for bunny nose
            mysteryBox: '#FFD700',      // Gold mystery boxes
            mysteryBoxSymbol: '#000000', // Black question marks
            invincible: '#FFFF00',      // Yellow invincibility tint
            slowMotion: '#00FFFF',      // Cyan slow motion tint
            fastForward: '#FF4500'      // Orange fast forward tint
        };

        // Game States
        /**
         * GAME STATES
         * Defines all possible game states for state machine
         */
        const GAME_STATES = {
            TITLE: 'title',           // Main menu screen
            PLAYING: 'playing',       // Active gameplay
            PAUSED: 'paused',         // Game paused by player
            HIT_PAUSE: 'hitPause',    // Paused after taking damage
            GAME_OVER: 'gameOver'     // End game screen
        };

        /**
         * DIFFICULTY THRESHOLDS
         * Score-based progression milestones for dynamic difficulty scaling
         */
        const SCORE_THRESHOLDS = {
            OBSTACLES_START: 100,      // When obstacles first appear
            SPEED_INCREASE: 200,       // When carrot speed increases
            MULTI_SPAWN_START: 300,    // When multi-carrot spawns begin
            RAPID_INCREASE: 500        // When rapid difficulty scaling begins
        };

        // Main Game Class
        /**
         * BUNNY BAG GAME CLASS
         * Main game controller and state manager
         * 
         * @class BunnyBagGame
         * @description Retro-style HTML5 Canvas arcade game featuring a bunny character
         *              who must catch falling carrots while avoiding moving obstacles.
         *              Features progressive difficulty, power-ups, and 8-bit aesthetics.
         */
        class BunnyBagGame {
            /**
             * Initialize the game instance
             * @constructor
             */
            constructor() {
                // Canvas and rendering context
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.crtOverlay = document.getElementById('crtOverlay');
                
                // Game state management
                this.state = GAME_STATES.TITLE;
                this.score = 0;
                this.lives = 3;
                this.difficultyLevel = 1;
                this.difficultyProgress = 0;
                this.caughtCarrots = 0;
                this.totalCarrots = 0;
                this.combo = 0;
                this.maxCombo = 0;
                this.bestScore = parseInt(localStorage.getItem('bunnyBagBestScore') || '0');
                
                // Hit pause state
                this.hitPauseTime = 0;
                
                // Player
                this.player = {
                    x: GAME_WIDTH / 2 - PLAYER_WIDTH / 2,
                    y: GROUND_Y - PLAYER_HEIGHT,
                    width: PLAYER_WIDTH,
                    height: PLAYER_HEIGHT,
                    speed: 4,
                    direction: 0,
                    velocityY: 0,
                    onGround: true,
                    canJump: true
                };
                
                // Game Objects
                this.carrots = [];
                this.obstacles = [];
                this.mysteryBoxes = [];
                this.particles = [];
                
                // Power-up states
                this.invincible = false;
                this.invincibleTime = 0;
                this.slowMotion = false;
                this.slowMotionTime = 0;
                this.fastForward = false;
                this.fastForwardTime = 0;
                
                // Timing
                this.lastSpawnTime = 0;
                this.lastObstacleSpawnTime = 0;
                this.lastMysteryBoxSpawnTime = 0;
                this.mysteryBoxStartTime = 0; // Delay before first mystery box can appear
                this.gameTime = 0;
                this.lastFrameTime = 0;
                this.deltaTime = 0;
                
                // Settings
                this.muted = false;
                this.crtEnabled = false;
                
                // Input
                this.keys = {};
                
                this.init();
            }
            
            /**
             * Initialize the game and start the main game loop
             * @method init
             */
            init() {
                this.setupEventListeners();
                this.gameLoop();
            }
            
            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    this.handleKeyPress(e);
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // Touch controls setup
                this.setupTouchControls();
            }
            
            setupTouchControls() {
                const touchToggle = document.getElementById('touchToggle');
                const touchControls = document.getElementById('touchControls');
                const leftBtn = document.getElementById('leftBtn');
                const rightBtn = document.getElementById('rightBtn');
                const jumpBtn = document.getElementById('jumpBtn');
                
                // Toggle touch controls
                touchToggle.addEventListener('click', () => {
                    touchControls.classList.toggle('show');
                    touchToggle.textContent = touchControls.classList.contains('show') ? '‚å®Ô∏è Keys' : 'üì± Touch';
                });
                
                // Touch button events
                leftBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.keys['ArrowLeft'] = true;
                });
                
                leftBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.keys['ArrowLeft'] = false;
                });
                
                rightBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.keys['ArrowRight'] = true;
                });
                
                rightBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.keys['ArrowRight'] = false;
                });
                
                jumpBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleJump();
                });
                
                // Mouse events for desktop testing
                leftBtn.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.keys['ArrowLeft'] = true;
                });
                
                leftBtn.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    this.keys['ArrowLeft'] = false;
                });
                
                rightBtn.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.keys['ArrowRight'] = true;
                });
                
                rightBtn.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    this.keys['ArrowRight'] = false;
                });
                
                jumpBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    this.handleJump();
                });
            }
            
            handleKeyPress(e) {
                switch (e.code) {
                    case 'Space':
                        e.preventDefault();
                        this.handleSpaceKey();
                        break;
                    case 'KeyM':
                        this.toggleMute();
                        break;
                    case 'KeyC':
                        this.toggleCRT();
                        break;
                    case 'ArrowUp':
                    case 'KeyW':
                    case 'KeyS':
                        e.preventDefault();
                        this.handleJump();
                        break;
                }
            }
            
            handleSpaceKey() {
                switch (this.state) {
                    case GAME_STATES.TITLE:
                        this.startGame();
                        break;
                    case GAME_STATES.PLAYING:
                        this.pauseGame();
                        break;
                    case GAME_STATES.PAUSED:
                        this.resumeGame();
                        break;
                    case GAME_STATES.HIT_PAUSE:
                        this.resumeFromHit();
                        break;
                    case GAME_STATES.GAME_OVER:
                        this.restartGame();
                        break;
                }
            }
            
            toggleMute() {
                this.muted = !this.muted;
            }
            
            toggleCRT() {
                this.crtEnabled = !this.crtEnabled;
                this.crtOverlay.classList.toggle('active', this.crtEnabled);
            }
            
            handleJump() {
                if (this.state === GAME_STATES.PLAYING && this.player.canJump && this.player.onGround) {
                    this.player.velocityY = -JUMP_POWER;
                    this.player.onGround = false;
                    this.player.canJump = false;
                }
            }
            
            startGame() {
                this.state = GAME_STATES.PLAYING;
                this.resetGame();
                this.mysteryBoxStartTime = Date.now() + 30000; // 30 second delay before first mystery box
            }
            
            pauseGame() {
                this.state = GAME_STATES.PAUSED;
            }
            
            resumeGame() {
                this.state = GAME_STATES.PLAYING;
            }
            
            resumeFromHit() {
                this.state = GAME_STATES.PLAYING;
                this.hitPauseTime = 0;
            }
            
            restartGame() {
                this.state = GAME_STATES.TITLE;
                this.resetGame();
            }
            
            resetGame() {
                this.score = 0;
                this.lives = 3;
                this.difficultyLevel = 1;
                this.difficultyProgress = 0;
                this.caughtCarrots = 0;
                this.totalCarrots = 0;
                this.combo = 0;
                this.maxCombo = 0;
                this.carrots = [];
                this.obstacles = [];
                this.mysteryBoxes = [];
                this.particles = [];
                this.player.x = GAME_WIDTH / 2 - PLAYER_WIDTH / 2;
                this.player.y = GROUND_Y - PLAYER_HEIGHT;
                this.player.velocityY = 0;
                this.player.onGround = true;
                this.player.canJump = true;
                this.lastSpawnTime = 0;
                this.lastObstacleSpawnTime = 0;
                this.lastMysteryBoxSpawnTime = 0;
                this.mysteryBoxStartTime = 0;
                this.gameTime = 0;
                this.hitPauseTime = 0;
                this.invincible = false;
                this.invincibleTime = 0;
                this.slowMotion = false;
                this.slowMotionTime = 0;
                this.fastForward = false;
                this.fastForwardTime = 0;
            }
            
            gameOver() {
                this.state = GAME_STATES.GAME_OVER;
                
                if (this.score > this.bestScore) {
                    this.bestScore = this.score;
                    localStorage.setItem('bunnyBagBestScore', this.bestScore.toString());
                }
            }
            
            /**
             * Main game update loop - handles all game logic
             * @method update
             * @param {number} deltaTime - Time elapsed since last frame in milliseconds
             */
            update(deltaTime) {
                if (this.state !== GAME_STATES.PLAYING) return;
                
                // Apply power-up speed effects
                let speedMultiplier = 1;
                if (this.slowMotion) speedMultiplier = 0.5;
                if (this.fastForward) speedMultiplier = 1.5;
                
                const adjustedDeltaTime = deltaTime * speedMultiplier;
                this.gameTime += adjustedDeltaTime;
                
                this.updatePlayer(adjustedDeltaTime);
                this.updateCarrots(adjustedDeltaTime);
                this.updateObstacles(adjustedDeltaTime);
                this.updateMysteryBoxes(adjustedDeltaTime);
                this.updateParticles(adjustedDeltaTime);
                this.updatePowerUps(deltaTime); // Power-up timers use real time
                this.spawnCarrots();
                this.spawnObstacles();
                this.spawnMysteryBoxes();
                this.updateDifficultyProgression();
            }
            
            updatePlayer(deltaTime) {
                if (this.keys['ArrowLeft'] || this.keys['KeyA']) {
                    this.player.direction = -1;
                } else if (this.keys['ArrowRight'] || this.keys['KeyD']) {
                    this.player.direction = 1;
                } else {
                    this.player.direction = 0;
                }
                
                this.player.x += this.player.direction * this.player.speed;
                
                if (!this.player.onGround) {
                    this.player.velocityY += GRAVITY;
                    this.player.y += this.player.velocityY;
                    
                    if (this.player.y >= GROUND_Y - this.player.height) {
                        this.player.y = GROUND_Y - this.player.height;
                        this.player.velocityY = 0;
                        this.player.onGround = true;
                        this.player.canJump = true;
                    }
                }
                
                this.player.x = Math.max(0, Math.min(GAME_WIDTH - this.player.width, this.player.x));
            }
            
            updateCarrots(deltaTime) {
                const config = this.getDifficultyConfig();
                
                for (let i = this.carrots.length - 1; i >= 0; i--) {
                    const carrot = this.carrots[i];
                    carrot.y += carrot.speed * deltaTime * 0.1;
                    
                    if (this.checkCarrotCollision(carrot)) {
                        this.catchCarrot(carrot, i);
                        continue;
                    }
                    
                    if (carrot.y > GAME_HEIGHT - 20) {
                        this.groundCarrot(carrot, i);
                    }
                }
            }
            
            updateObstacles(deltaTime) {
                for (let i = this.obstacles.length - 1; i >= 0; i--) {
                    const obstacle = this.obstacles[i];
                    obstacle.x -= obstacle.speed;
                    
                    // Add creature movement patterns
                    if (obstacle.type === 'flyingBug') {
                        // Flying bugs move up and down
                        obstacle.movementOffset += obstacle.movementSpeed * obstacle.direction;
                        obstacle.y = obstacle.originalY + Math.sin(obstacle.movementOffset) * 20;
                    } else if (obstacle.type === 'jumpingSpider') {
                        // Jumping spiders bounce
                        obstacle.movementOffset += obstacle.movementSpeed;
                        obstacle.y = obstacle.originalY + Math.abs(Math.sin(obstacle.movementOffset * 2)) * 15;
                    } else if (obstacle.type === 'slitheringSnake') {
                        // Snakes slither side to side
                        obstacle.movementOffset += obstacle.movementSpeed;
                        obstacle.y = obstacle.originalY + Math.sin(obstacle.movementOffset * 0.5) * 8;
                    }
                    
                    if (this.checkObstacleCollision(obstacle)) {
                        this.hitObstacle(obstacle, i);
                        continue;
                    }
                    
                    if (obstacle.x + obstacle.width < 0) {
                        this.obstacles.splice(i, 1);
                    }
                }
            }
            
            updateMysteryBoxes(deltaTime) {
                for (let i = this.mysteryBoxes.length - 1; i >= 0; i--) {
                    const mysteryBox = this.mysteryBoxes[i];
                    mysteryBox.x -= mysteryBox.speed;
                    
                    if (this.checkMysteryBoxCollision(mysteryBox)) {
                        this.hitMysteryBox(mysteryBox, i);
                        continue;
                    }
                    
                    if (mysteryBox.x + mysteryBox.width < 0) {
                        this.mysteryBoxes.splice(i, 1);
                    }
                }
            }
            
            updateParticles(deltaTime) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.x += particle.vx * deltaTime * 0.1;
                    particle.y += particle.vy * deltaTime * 0.1;
                    particle.life -= deltaTime;
                    
                    // Update flash timer for negative rewards
                    if (particle.isNegative) {
                        particle.flashTimer += deltaTime;
                    }
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            updatePowerUps(deltaTime) {
                const now = Date.now();
                
                // Update invincibility
                if (this.invincible && now - this.invincibleTime > 15000) {
                    this.invincible = false;
                }
                
                // Update slow motion
                if (this.slowMotion && now - this.slowMotionTime > 5000) {
                    this.slowMotion = false;
                }
                
                // Update fast forward
                if (this.fastForward && now - this.fastForwardTime > 3000) {
                    this.fastForward = false;
                }
            }
            
            spawnCarrots() {
                const config = this.getDifficultyConfig();
                const now = Date.now();
                
                if (now - this.lastSpawnTime > config.spawnInterval) {
                    this.createCarrot();
                    
                    if (Math.random() < config.multiSpawn) {
                        setTimeout(() => this.createCarrot(), 200);
                        if (Math.random() < config.multiSpawn * 0.5) {
                            setTimeout(() => this.createCarrot(), 400);
                        }
                    }
                    
                    this.lastSpawnTime = now;
                }
            }
            
            spawnObstacles() {
                const config = this.getDifficultyConfig();
                
                if (!config.obstacles) return;
                
                const now = Date.now();
                const obstacleSpawnInterval = 4000;
                
                if (now - this.lastObstacleSpawnTime > obstacleSpawnInterval) {
                    if (Math.random() < config.obstacleSpawn) {
                        this.createObstacle();
                        this.lastObstacleSpawnTime = now;
                    }
                }
            }
            
            spawnMysteryBoxes() {
                const now = Date.now();
                
                // Don't spawn mystery boxes until the start delay has passed
                if (now < this.mysteryBoxStartTime) return;
                
                const mysteryBoxSpawnInterval = 60000; // 75% less frequent - extremely rare and special
                
                if (now - this.lastMysteryBoxSpawnTime > mysteryBoxSpawnInterval) {
                    if (Math.random() < 0.15) { // 15% chance to spawn - extremely rare
                        this.createMysteryBox();
                        this.lastMysteryBoxSpawnTime = now;
                    }
                }
            }
            
            createCarrot() {
                const config = this.getDifficultyConfig();
                
                let x;
                if (this.score < 200) {
                    x = Math.random() * (GAME_WIDTH - CARROT_SIZE);
                } else if (this.score < 500) {
                    if (this.carrots.length > 0) {
                        const lastCarrot = this.carrots[this.carrots.length - 1];
                        const offset = (Math.random() - 0.5) * 150;
                        x = Math.max(0, Math.min(GAME_WIDTH - CARROT_SIZE, lastCarrot.x + offset));
                    } else {
                        x = Math.random() * (GAME_WIDTH - CARROT_SIZE);
                    }
                } else {
                    if (this.carrots.length > 0) {
                        const lastCarrot = this.carrots[this.carrots.length - 1];
                        const offset = (Math.random() - 0.5) * 200;
                        x = Math.max(0, Math.min(GAME_WIDTH - CARROT_SIZE, lastCarrot.x + offset));
                    } else {
                        x = Math.random() * (GAME_WIDTH - CARROT_SIZE);
                    }
                }
                
                const carrot = {
                    x: x,
                    y: -CARROT_SIZE,
                    width: CARROT_SIZE,
                    height: CARROT_SIZE,
                    speed: config.fallSpeed + (Math.random() - 0.5) * 0.3,
                    rotation: 0
                };
                
                this.carrots.push(carrot);
                this.totalCarrots++;
            }
            
            createObstacle() {
                const config = this.getDifficultyConfig();
                const obstacleTypes = ['log', 'rock', 'flyingBug', 'jumpingSpider', 'slitheringSnake'];
                const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                
                const obstacle = {
                    x: GAME_WIDTH,
                    y: GROUND_Y - OBSTACLE_HEIGHT,
                    width: OBSTACLE_WIDTH,
                    height: OBSTACLE_HEIGHT,
                    speed: config.obstacleSpeed,
                    type: type,
                    // Movement properties for creatures
                    originalY: GROUND_Y - OBSTACLE_HEIGHT,
                    movementOffset: 0,
                    movementSpeed: Math.random() * 0.1 + 0.05, // Random movement speed
                    direction: Math.random() < 0.5 ? 1 : -1 // Random movement direction
                };
                
                this.obstacles.push(obstacle);
            }
            
            createMysteryBox() {
                const config = this.getDifficultyConfig();
                
                // Vary speed significantly - sometimes very fast, sometimes very slow
                const speedVariation = Math.random();
                let speed;
                if (speedVariation < 0.3) {
                    speed = config.obstacleSpeed * 0.3; // Very slow
                } else if (speedVariation < 0.6) {
                    speed = config.obstacleSpeed * 0.7; // Medium slow
                } else if (speedVariation < 0.8) {
                    speed = config.obstacleSpeed * 1.2; // Fast
                } else {
                    speed = config.obstacleSpeed * 1.8; // Very fast
                }
                
                const mysteryBox = {
                    x: GAME_WIDTH,
                    y: MYSTERY_BOX_HEIGHT,
                    width: MYSTERY_BOX_SIZE,
                    height: MYSTERY_BOX_SIZE,
                    speed: speed,
                    hit: false
                };
                
                this.mysteryBoxes.push(mysteryBox);
            }
            
            checkCarrotCollision(carrot) {
                const bagX = this.player.x + (this.player.width - BAG_WIDTH) / 2;
                const bagY = this.player.y - BAG_HEIGHT;
                
                return carrot.x < bagX + BAG_WIDTH &&
                       carrot.x + carrot.width > bagX &&
                       carrot.y < bagY + BAG_HEIGHT &&
                       carrot.y + carrot.height > bagY;
            }
            
            checkObstacleCollision(obstacle) {
                return this.player.x < obstacle.x + obstacle.width &&
                       this.player.x + this.player.width > obstacle.x &&
                       this.player.y < obstacle.y + obstacle.height &&
                       this.player.y + this.player.height > obstacle.y;
            }
            
            checkMysteryBoxCollision(mysteryBox) {
                // Check if player is jumping and hitting from below
                const playerTop = this.player.y;
                const playerBottom = this.player.y + this.player.height;
                const playerLeft = this.player.x;
                const playerRight = this.player.x + this.player.width;
                
                const boxBottom = mysteryBox.y + mysteryBox.height;
                const boxLeft = mysteryBox.x;
                const boxRight = mysteryBox.x + mysteryBox.width;
                
                // Player must be jumping (not on ground) and hitting from below
                return !this.player.onGround && 
                       playerTop < boxBottom && 
                       playerBottom > mysteryBox.y &&
                       playerLeft < boxRight && 
                       playerRight > boxLeft &&
                       !mysteryBox.hit;
            }
            
            catchCarrot(carrot, index) {
                this.carrots.splice(index, 1);
                
                this.score += 10;
                this.caughtCarrots++;
                this.combo++;
                this.maxCombo = Math.max(this.maxCombo, this.combo);
                
                this.createCatchParticles(carrot.x + carrot.width / 2, carrot.y + carrot.height / 2);
            }
            
            groundCarrot(carrot, index) {
                this.carrots.splice(index, 1);
                this.combo = 0;
                this.createGroundParticles(carrot.x + carrot.width / 2, carrot.y + carrot.height / 2);
            }
            
            hitObstacle(obstacle, index) {
                this.obstacles.splice(index, 1);
                this.combo = 0;
                
                // Only lose life if NOT invincible
                if (!this.invincible) {
                    this.lives--;
                    this.createHitParticles(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2);
                    
                    this.state = GAME_STATES.HIT_PAUSE;
                    this.hitPauseTime = Date.now();
                    
                    if (this.lives <= 0) {
                        this.gameOver();
                    }
                } else {
                    // If invincible, just create invincible hit particles and continue
                    this.createInvincibleHitParticles(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2);
                }
            }
            
            hitMysteryBox(mysteryBox, index) {
                mysteryBox.hit = true;
                this.mysteryBoxes.splice(index, 1);
                
                // Create mystery box hit particles
                this.createMysteryBoxParticles(mysteryBox.x + mysteryBox.width / 2, mysteryBox.y + mysteryBox.height / 2);
                
                // Randomly select reward (80% positive, 20% negative) - much more positive
                const isPositive = Math.random() < 0.8;
                
                if (isPositive) {
                    // Positive rewards
                    const positiveRewards = [
                        () => { this.score += 50; this.createRewardText('+50 POINTS!', COLORS.carrot); },
                        () => { this.score += 100; this.createRewardText('+100 POINTS!', COLORS.carrot); },
                        () => { this.score += 200; this.createRewardText('+200 POINTS!', COLORS.carrot); },
                        () => { 
                            if (this.lives < 3) {
                                this.lives += 1;
                                this.createRewardText('EXTRA LIFE!', COLORS.player);
                            } else {
                                this.score += 100; // Bonus points if already at max lives
                                this.createRewardText('MAX LIVES! +100 POINTS', COLORS.carrot);
                            }
                        },
                        () => { this.invincible = true; this.invincibleTime = Date.now(); this.createRewardText('INVINCIBLE!', COLORS.invincible); },
                        () => { this.slowMotion = true; this.slowMotionTime = Date.now(); this.createRewardText('SLOW MOTION!', COLORS.slowMotion); }
                    ];
                    const reward = positiveRewards[Math.floor(Math.random() * positiveRewards.length)];
                    reward();
                } else {
                    // Negative rewards
                    const negativeRewards = [
                        () => { this.score = Math.max(0, this.score - 10); this.createRewardText('-10 POINTS', COLORS.shadow); },
                        () => { this.score = Math.max(0, this.score - 20); this.createRewardText('-20 POINTS', COLORS.shadow); },
                        () => { this.score = Math.max(0, this.score - 30); this.createRewardText('-30 POINTS', COLORS.shadow); },
                        () => { this.score = Math.max(0, this.score - 40); this.createRewardText('-40 POINTS', COLORS.shadow); },
                        () => { this.score = Math.max(0, this.score - 50); this.createRewardText('-50 POINTS', COLORS.shadow); },
                        () => { this.fastForward = true; this.fastForwardTime = Date.now(); this.createRewardText('FAST FORWARD!', COLORS.fastForward); }
                    ];
                    const penalty = negativeRewards[Math.floor(Math.random() * negativeRewards.length)];
                    penalty();
                }
            }
            
            /**
             * Calculate difficulty configuration based on current score
             * @method getDifficultyConfig
             * @returns {Object} Difficulty configuration object
             */
            getDifficultyConfig() {
                const config = {
                    spawnInterval: 2000,    // Carrot spawn interval in ms
                    fallSpeed: 2,           // Carrot fall speed
                    multiSpawn: 0,          // Multi-carrot spawn chance
                    obstacles: false,       // Whether obstacles are enabled
                    obstacleSpawn: 0,       // Obstacle spawn rate (0-1)
                    obstacleSpeed: 2.5      // Obstacle movement speed
                };
                
                const score = this.score;
                
                if (score >= SCORE_THRESHOLDS.OBSTACLES_START) {
                    config.obstacles = true;
                    config.obstacleSpawn = Math.min(0.3, 0.05 + (score - SCORE_THRESHOLDS.OBSTACLES_START) * 0.001);
                    config.obstacleSpeed = Math.min(4.5, 2.5 + (score - SCORE_THRESHOLDS.OBSTACLES_START) * 0.01);
                }
                
                if (score >= SCORE_THRESHOLDS.SPEED_INCREASE) {
                    const speedMultiplier = 1 + (score - SCORE_THRESHOLDS.SPEED_INCREASE) * 0.005; // Much slower carrot speed increase
                    config.fallSpeed = Math.min(4, 2 * speedMultiplier); // Cap at 4 instead of 8
                    config.spawnInterval = Math.max(500, 2000 / speedMultiplier); // Less frequent carrots
                }
                
                if (score >= SCORE_THRESHOLDS.MULTI_SPAWN_START) {
                    config.multiSpawn = Math.min(0.5, (score - SCORE_THRESHOLDS.MULTI_SPAWN_START) * 0.003);
                }
                
                if (score >= SCORE_THRESHOLDS.RAPID_INCREASE) {
                    const rapidMultiplier = 1 + (score - SCORE_THRESHOLDS.RAPID_INCREASE) * 0.01;
                    config.fallSpeed = Math.min(5, config.fallSpeed * rapidMultiplier); // Much lower cap
                    config.spawnInterval = Math.max(300, config.spawnInterval / rapidMultiplier);
                    config.obstacleSpeed = Math.min(6.5, config.obstacleSpeed * rapidMultiplier); // Higher obstacle speed
                    config.obstacleSpawn = Math.min(0.6, config.obstacleSpawn * rapidMultiplier); // More frequent obstacles
                }
                
                return config;
            }
            
            updateDifficultyProgression() {
                const newLevel = Math.floor(this.score / 25) + 1;
                if (newLevel > this.difficultyLevel) {
                    this.difficultyLevel = newLevel;
                    this.createStageUpParticles();
                }
            }
            
            createCatchParticles(x, y) {
                for (let i = 0; i < 5; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4 - 2,
                        life: 1000,
                        color: COLORS.carrot
                    });
                }
            }
            
            createGroundParticles(x, y) {
                for (let i = 0; i < 3; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: 500,
                        color: COLORS.ground
                    });
                }
            }
            
            createHitParticles(x, y) {
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6 - 3,
                        life: 800,
                        color: COLORS.shadow
                    });
                }
            }
            
            createInvincibleHitParticles(x, y) {
                for (let i = 0; i < 12; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8 - 4,
                        life: 1000,
                        color: COLORS.invincible
                    });
                }
            }
            
            createStageUpParticles() {
                for (let i = 0; i < 20; i++) {
                    this.particles.push({
                        x: GAME_WIDTH / 2,
                        y: GAME_HEIGHT / 2,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 2000,
                        color: COLORS.ui
                    });
                }
            }
            
            createMysteryBoxParticles(x, y) {
                for (let i = 0; i < 10; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6 - 2,
                        life: 1500,
                        color: COLORS.mysteryBox
                    });
                }
            }
            
            createRewardText(text, color) {
                // Create floating text effect - bigger and longer lasting
                const isNegative = text.includes('-') || text.includes('FAST FORWARD');
                this.particles.push({
                    x: GAME_WIDTH / 2,
                    y: GAME_HEIGHT / 2,
                    vx: 0,
                    vy: -1, // Slower movement
                    life: 4000, // Last twice as long
                    color: color,
                    text: text,
                    isText: true,
                    isNegative: isNegative, // Flag for negative rewards
                    flashTimer: 0 // Timer for flashing effect
                });
            }
            
            render() {
                this.ctx.fillStyle = COLORS.background;
                this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                
                this.ctx.fillStyle = COLORS.ground;
                this.ctx.fillRect(0, GAME_HEIGHT - 20, GAME_WIDTH, 20);
                
                switch (this.state) {
                    case GAME_STATES.TITLE:
                        this.renderTitleScreen();
                        break;
                    case GAME_STATES.PLAYING:
                    case GAME_STATES.PAUSED:
                    case GAME_STATES.HIT_PAUSE:
                        this.renderGameplay();
                        if (this.state === GAME_STATES.PAUSED) {
                            this.renderPauseOverlay();
                        } else if (this.state === GAME_STATES.HIT_PAUSE) {
                            this.renderHitPauseOverlay();
                        }
                        break;
                    case GAME_STATES.GAME_OVER:
                        this.renderGameplay();
                        this.renderGameOverScreen();
                        break;
                }
            }
            
            renderTitleScreen() {
                this.ctx.fillStyle = COLORS.ui;
                this.ctx.font = 'bold 48px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('BUNNY BAG', GAME_WIDTH / 2, 150);
                
                this.ctx.font = 'bold 24px monospace';
                this.ctx.fillText('Carrot Catcher', GAME_WIDTH / 2, 190);
                
                // Make the main instructions BIGGER and ALL CAPS
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = 'bold 20px monospace';
                this.ctx.fillText('CATCH FALLING CARROTS WITH YOUR BAG!', GAME_WIDTH / 2, 250);
                this.ctx.fillText('EACH CARROT = 10 POINTS!', GAME_WIDTH / 2, 280);
                this.ctx.fillText('TIMING IS KEY!', GAME_WIDTH / 2, 310);
                this.ctx.fillText('LOSE LIVES WHEN HIT BY OBSTACLES!', GAME_WIDTH / 2, 340);
                
                // Make the start section much more prominent
                this.ctx.fillStyle = '#FF0000'; // Bright red
                this.ctx.font = 'bold 24px monospace';
                this.ctx.fillText('SPACE to Start', GAME_WIDTH / 2, 390);
                
                // Make the controls in the red square LARGER
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = 'bold 20px monospace';
                this.ctx.fillText('‚Üê ‚Üí or A D Move | ‚Üë or W S Jump', GAME_WIDTH / 2, 420);
                
                if (this.bestScore > 0) {
                    this.ctx.fillStyle = COLORS.carrot;
                    this.ctx.font = 'bold 18px monospace';
                    this.ctx.fillText(`Score: ${this.bestScore}`, GAME_WIDTH / 2, 450);
                }
            }
            
            renderGameplay() {
                // Apply power-up effects to background
                if (this.invincible) {
                    this.ctx.fillStyle = 'rgba(255, 255, 0, 0.1)';
                    this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                } else if (this.slowMotion) {
                    this.ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
                    this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                } else if (this.fastForward) {
                    this.ctx.fillStyle = 'rgba(255, 69, 0, 0.1)';
                    this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                }
                
                this.obstacles.forEach(obstacle => {
                    this.renderObstacle(obstacle);
                });
                
                this.mysteryBoxes.forEach(mysteryBox => {
                    this.renderMysteryBox(mysteryBox);
                });
                
                this.carrots.forEach(carrot => {
                    this.renderCarrot(carrot);
                });
                
                this.renderPlayer();
                
                this.particles.forEach(particle => {
                    if (particle.isText) {
                        // Flashing effect for negative rewards
                        if (particle.isNegative) {
                            const flashSpeed = 200; // Milliseconds per flash
                            const flashPhase = Math.floor(particle.flashTimer / flashSpeed) % 2;
                            this.ctx.fillStyle = flashPhase === 0 ? '#FF0000' : '#FFFFFF'; // Red and white flashing
                        } else {
                            this.ctx.fillStyle = particle.color;
                        }
                        
                        this.ctx.font = 'bold 24px monospace'; // Much bigger text
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(particle.text, particle.x, particle.y);
                    } else {
                        this.ctx.fillStyle = particle.color;
                        this.ctx.fillRect(particle.x, particle.y, 2, 2);
                    }
                });
                
                this.renderUI();
            }
            
            renderCarrot(carrot) {
                // Enhanced carrot rendering with your custom design
                this.renderCarrotBody(carrot);
                this.renderCarrotTop(carrot);
            }
            
            renderCarrotBody(carrot) {
                const x = carrot.x;
                const y = carrot.y;
                
                // Base orange color - made even larger and longer
                this.ctx.fillStyle = '#FF8C00';
                this.ctx.fillRect(x, y + 4, 16, 16);
                
                // Darker orange shading
                this.ctx.fillStyle = '#FF7F00';
                this.ctx.fillRect(x + 1, y + 5, 14, 14);
                this.ctx.fillRect(x + 2, y + 6, 12, 12);
                this.ctx.fillRect(x + 3, y + 7, 10, 10);
                this.ctx.fillRect(x + 4, y + 8, 8, 8);
                
                // Lighter orange highlights
                this.ctx.fillStyle = '#FFA500';
                this.ctx.fillRect(x - 1, y + 4, 2, 16);
                this.ctx.fillRect(x + 15, y + 4, 2, 16);
                
                // Carrot tip - made much longer and more tapered
                this.ctx.fillStyle = '#FF8C00';
                this.ctx.fillRect(x + 4, y + 20, 8, 4);
                this.ctx.fillRect(x + 5, y + 24, 6, 3);
                this.ctx.fillRect(x + 6, y + 27, 4, 2);
                this.ctx.fillRect(x + 7, y + 29, 2, 1);
            }
            
            renderCarrotTop(carrot) {
                const x = carrot.x;
                const y = carrot.y;
                
                // Main green leafy top - much larger for bigger carrot
                this.ctx.fillStyle = '#32CD32';
                this.ctx.fillRect(x + 2, y, 12, 8);
                
                // Darker green for depth
                this.ctx.fillStyle = '#228B22';
                this.ctx.fillRect(x + 3, y + 1, 10, 6);
                
                // Individual leaf structures - much larger
                this.ctx.fillStyle = '#32CD32';
                // Left leaf
                this.ctx.fillRect(x, y - 1, 5, 6);
                this.ctx.fillRect(x - 1, y, 2, 4);
                
                // Right leaf
                this.ctx.fillRect(x + 11, y - 1, 5, 6);
                this.ctx.fillRect(x + 15, y, 2, 4);
                
                // Center leaves
                this.ctx.fillRect(x + 3, y - 2, 4, 5);
                this.ctx.fillRect(x + 9, y - 2, 4, 5);
                
                // Small tendrils - much more prominent
                this.ctx.fillStyle = '#90EE90';
                this.ctx.fillRect(x + 4, y - 3, 1, 4);
                this.ctx.fillRect(x + 11, y - 3, 1, 4);
                this.ctx.fillRect(x + 5, y - 4, 1, 2);
                this.ctx.fillRect(x + 10, y - 4, 1, 2);
                this.ctx.fillRect(x + 6, y - 5, 1, 1);
                this.ctx.fillRect(x + 9, y - 5, 1, 1);
                this.ctx.fillRect(x + 7, y - 6, 1, 1);
                this.ctx.fillRect(x + 8, y - 6, 1, 1);
            }
            
            renderPlayer() {
                // Draw the brown sack first (behind the bunny)
                this.renderSack();
                
                // Draw the bunny character
                this.renderBunnyCharacter();
            }
            
            renderSack() {
                const bagX = this.player.x + (this.player.width - BAG_WIDTH) / 2;
                const bagY = this.player.y - BAG_HEIGHT;
                
                // Main sack body - brown with texture (reduced by 40%)
                this.ctx.fillStyle = '#8B4513'; // Brown
                this.ctx.fillRect(bagX, bagY, BAG_WIDTH, BAG_HEIGHT);
                
                // Sack texture - darker brown pattern (reduced by 40%)
                this.ctx.fillStyle = '#654321';
                this.ctx.fillRect(bagX + 4, bagY + 4, 4, 4);
                this.ctx.fillRect(bagX + 11, bagY + 4, 4, 4);
                this.ctx.fillRect(bagX + 18, bagY + 4, 4, 4);
                this.ctx.fillRect(bagX + 25, bagY + 4, 4, 4);
                this.ctx.fillRect(bagX + 32, bagY + 4, 4, 4);
                this.ctx.fillRect(bagX + 39, bagY + 4, 4, 4);
                this.ctx.fillRect(bagX + 46, bagY + 4, 4, 4);
                this.ctx.fillRect(bagX + 53, bagY + 4, 4, 4);
                this.ctx.fillRect(bagX + 60, bagY + 4, 4, 4);
                
                this.ctx.fillRect(bagX + 7, bagY + 7, 4, 4);
                this.ctx.fillRect(bagX + 14, bagY + 7, 4, 4);
                this.ctx.fillRect(bagX + 21, bagY + 7, 4, 4);
                this.ctx.fillRect(bagX + 28, bagY + 7, 4, 4);
                this.ctx.fillRect(bagX + 35, bagY + 7, 4, 4);
                this.ctx.fillRect(bagX + 42, bagY + 7, 4, 4);
                this.ctx.fillRect(bagX + 49, bagY + 7, 4, 4);
                this.ctx.fillRect(bagX + 56, bagY + 7, 4, 4);
                
                // Sack opening - darker interior (reduced by 40%)
                this.ctx.fillStyle = '#4A2C17';
                this.ctx.fillRect(bagX + 7, bagY + 22, BAG_WIDTH - 14, 11);
            }
            
            renderBunnyCharacter() {
                // Draw bunny head - light gray (reduced by 40%)
                this.ctx.fillStyle = '#D3D3D3'; // Light gray
                this.ctx.fillRect(this.player.x + 11, this.player.y + 4, 36, 29);
                
                // Draw bunny ears - light gray with pink inner (reduced by 40%)
                this.ctx.fillStyle = '#D3D3D3';
                this.ctx.fillRect(this.player.x + 14, this.player.y - 14, 7, 18);
                this.ctx.fillRect(this.player.x + 36, this.player.y - 14, 7, 18);
                
                // Inner ears - pink (reduced by 40%)
                this.ctx.fillStyle = '#FFB6C1'; // Pink
                this.ctx.fillRect(this.player.x + 16, this.player.y - 11, 4, 11);
                this.ctx.fillRect(this.player.x + 38, this.player.y - 11, 4, 11);
                
                // Draw eyes - small black squares (reduced by 40%)
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(this.player.x + 18, this.player.y + 11, 4, 4);
                this.ctx.fillRect(this.player.x + 36, this.player.y + 11, 4, 4);
                
                // Draw nose - small black triangle (reduced by 40%)
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(this.player.x + 27, this.player.y + 18, 4, 2);
                this.ctx.fillRect(this.player.x + 25, this.player.y + 20, 8, 2);
                
                // Draw mouth - small line (reduced by 40%)
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(this.player.x + 25, this.player.y + 23, 8, 2);
                
                // Draw rosy cheeks - small pink circles (reduced by 40%)
                this.ctx.fillStyle = '#FFB6C1';
                this.ctx.fillRect(this.player.x + 14, this.player.y + 14, 4, 4);
                this.ctx.fillRect(this.player.x + 40, this.player.y + 14, 4, 4);
                
                // Draw black overalls/jumpsuit (reduced by 40%)
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(this.player.x + 7, this.player.y + 32, 43, 25);
                
                // Draw overalls straps (reduced by 40%)
                this.ctx.fillRect(this.player.x + 11, this.player.y + 32, 7, 14);
                this.ctx.fillRect(this.player.x + 40, this.player.y + 32, 7, 14);
                
                // Draw white buttons on straps (reduced by 40%)
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.fillRect(this.player.x + 13, this.player.y + 36, 4, 4);
                this.ctx.fillRect(this.player.x + 41, this.player.y + 36, 4, 4);
                
                // Draw arms holding sack - gray (reduced by 40%)
                this.ctx.fillStyle = '#D3D3D3';
                this.ctx.fillRect(this.player.x + 4, this.player.y + 36, 7, 14);
                this.ctx.fillRect(this.player.x + 47, this.player.y + 36, 7, 14);
                
                // Draw hands gripping sack (reduced by 40%)
                this.ctx.fillRect(this.player.x + 2, this.player.y + 40, 4, 7);
                this.ctx.fillRect(this.player.x + 52, this.player.y + 40, 4, 7);
                
                // Draw legs - gray (reduced by 40%)
                this.ctx.fillStyle = '#D3D3D3';
                this.ctx.fillRect(this.player.x + 14, this.player.y + 54, 11, 7);
                this.ctx.fillRect(this.player.x + 33, this.player.y + 54, 11, 7);
                
                // Draw red shoes (reduced by 40%)
                this.ctx.fillStyle = '#FF0000'; // Red
                this.ctx.fillRect(this.player.x + 11, this.player.y + 58, 18, 4);
                this.ctx.fillRect(this.player.x + 29, this.player.y + 58, 18, 4);
            }
            
            renderObstacle(obstacle) {
                if (this.player) {
                    const distanceToPlayer = obstacle.x - (this.player.x + this.player.width);
                    if (distanceToPlayer < 200 && distanceToPlayer > 0) {
                        this.ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                        this.ctx.fillRect(obstacle.x - 4, obstacle.y - 4, obstacle.width + 8, obstacle.height + 8);
                    }
                }
                
                if (obstacle.type === 'log') {
                    this.ctx.fillStyle = COLORS.obstacle;
                    this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    
                    this.ctx.fillStyle = COLORS.obstacleTop;
                    this.ctx.fillRect(obstacle.x + 2, obstacle.y + 2, obstacle.width - 4, 4);
                    this.ctx.fillRect(obstacle.x + 2, obstacle.y + 8, obstacle.width - 4, 2);
                    this.ctx.fillRect(obstacle.x + 2, obstacle.y + 14, obstacle.width - 4, 2);
                } else if (obstacle.type === 'rock') {
                    this.ctx.fillStyle = COLORS.shadow;
                    this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    
                    this.ctx.fillStyle = COLORS.obstacle;
                    this.ctx.fillRect(obstacle.x + 2, obstacle.y + 2, obstacle.width - 4, obstacle.height - 4);
                    
                    this.ctx.fillStyle = COLORS.obstacleTop;
                    this.ctx.fillRect(obstacle.x + 4, obstacle.y + 4, 4, 4);
                    this.ctx.fillRect(obstacle.x + 12, obstacle.y + 8, 4, 4);
                    this.ctx.fillRect(obstacle.x + 8, obstacle.y + 16, 4, 4);
                } else if (obstacle.type === 'flyingBug') {
                    // Flying bug - yellow with wings (BIGGER!)
                    this.ctx.fillStyle = '#FFD700'; // Gold
                    this.ctx.fillRect(obstacle.x + 2, obstacle.y + 2, 16, 12);
                    this.ctx.fillStyle = '#FFA500'; // Orange
                    this.ctx.fillRect(obstacle.x + 4, obstacle.y + 4, 12, 8);
                    // Wings
                    this.ctx.fillStyle = '#FFD700';
                    this.ctx.fillRect(obstacle.x - 2, obstacle.y, 8, 6);
                    this.ctx.fillRect(obstacle.x + 12, obstacle.y, 8, 6);
                    // Eyes
                    this.ctx.fillStyle = '#000000';
                    this.ctx.fillRect(obstacle.x + 4, obstacle.y + 4, 3, 3);
                    this.ctx.fillRect(obstacle.x + 11, obstacle.y + 4, 3, 3);
                } else if (obstacle.type === 'jumpingSpider') {
                    // Jumping spider - dark with legs (BIGGER!)
                    this.ctx.fillStyle = '#2F4F4F'; // Dark slate gray
                    this.ctx.fillRect(obstacle.x + 3, obstacle.y + 3, 14, 14);
                    // Legs
                    this.ctx.fillStyle = '#2F4F4F';
                    this.ctx.fillRect(obstacle.x - 2, obstacle.y + 6, 6, 3);
                    this.ctx.fillRect(obstacle.x + 16, obstacle.y + 6, 6, 3);
                    this.ctx.fillRect(obstacle.x + 1, obstacle.y + 10, 4, 3);
                    this.ctx.fillRect(obstacle.x + 15, obstacle.y + 10, 4, 3);
                    this.ctx.fillRect(obstacle.x + 2, obstacle.y + 14, 3, 3);
                    this.ctx.fillRect(obstacle.x + 15, obstacle.y + 14, 3, 3);
                    // Eyes
                    this.ctx.fillStyle = '#FF0000';
                    this.ctx.fillRect(obstacle.x + 5, obstacle.y + 5, 3, 3);
                    this.ctx.fillRect(obstacle.x + 12, obstacle.y + 5, 3, 3);
                } else if (obstacle.type === 'slitheringSnake') {
                    // Snake - green with pattern (BIGGER!)
                    this.ctx.fillStyle = '#228B22'; // Forest green
                    this.ctx.fillRect(obstacle.x + 1, obstacle.y + 4, 18, 12);
                    this.ctx.fillStyle = '#32CD32'; // Lime green
                    this.ctx.fillRect(obstacle.x + 3, obstacle.y + 5, 14, 10);
                    // Pattern
                    this.ctx.fillStyle = '#228B22';
                    this.ctx.fillRect(obstacle.x + 5, obstacle.y + 6, 3, 3);
                    this.ctx.fillRect(obstacle.x + 11, obstacle.y + 6, 3, 3);
                    this.ctx.fillRect(obstacle.x + 8, obstacle.y + 9, 3, 3);
                    this.ctx.fillRect(obstacle.x + 6, obstacle.y + 12, 2, 2);
                    this.ctx.fillRect(obstacle.x + 12, obstacle.y + 12, 2, 2);
                    // Head
                    this.ctx.fillStyle = '#32CD32';
                    this.ctx.fillRect(obstacle.x + 15, obstacle.y + 5, 6, 10);
                    // Eyes
                    this.ctx.fillStyle = '#000000';
                    this.ctx.fillRect(obstacle.x + 16, obstacle.y + 6, 2, 2);
                    this.ctx.fillRect(obstacle.x + 19, obstacle.y + 6, 2, 2);
                }
            }
            
            renderMysteryBox(mysteryBox) {
                // Draw mystery box with question mark
                this.ctx.fillStyle = COLORS.mysteryBox;
                this.ctx.fillRect(mysteryBox.x, mysteryBox.y, mysteryBox.width, mysteryBox.height);
                
                // Draw border
                this.ctx.strokeStyle = COLORS.shadow;
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(mysteryBox.x, mysteryBox.y, mysteryBox.width, mysteryBox.height);
                
                // Draw question mark (bigger for larger box)
                this.ctx.fillStyle = COLORS.mysteryBoxSymbol;
                this.ctx.font = 'bold 24px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('?', mysteryBox.x + mysteryBox.width / 2, mysteryBox.y + mysteryBox.height / 2 + 8);
                
                // Draw warning shadow when approaching
                if (this.player) {
                    const distanceToPlayer = mysteryBox.x - (this.player.x + this.player.width);
                    if (distanceToPlayer < 200 && distanceToPlayer > 0) {
                        this.ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                        this.ctx.fillRect(mysteryBox.x - 4, mysteryBox.y - 4, mysteryBox.width + 8, mysteryBox.height + 8);
                    }
                }
            }
            
            renderUI() {
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = 'bold 16px monospace';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`Score: ${this.score}`, 20, 30);
                
                this.ctx.fillText(`Lives: `, 20, 55);
                for (let i = 0; i < 3; i++) {
                    this.ctx.fillStyle = i < this.lives ? COLORS.player : COLORS.shadow;
                    this.ctx.fillText('‚ô•', 80 + i * 20, 55);
                }
                
                this.ctx.fillStyle = COLORS.ui;
                this.ctx.fillText(`Level: ${this.difficultyLevel}`, 20, 80);
                
                const accuracy = this.totalCarrots > 0 ? Math.round((this.caughtCarrots / this.totalCarrots) * 100) : 0;
                this.ctx.fillText(`Accuracy: ${accuracy}%`, 20, 105);
                
                if (this.combo > 0) {
                    this.ctx.fillStyle = COLORS.carrot;
                    this.ctx.fillText(`Combo: ${this.combo}`, 20, 130);
                }
                
                this.renderProgressBar();
            }
            
            renderProgressBar() {
                const barWidth = 200;
                const barHeight = 8;
                const barX = GAME_WIDTH - barWidth - 20;
                const barY = 20;
                
                this.ctx.fillStyle = COLORS.shadow;
                this.ctx.fillRect(barX, barY, barWidth, barHeight);
                
                const progress = Math.min(1, this.score / 1000);
                this.ctx.fillStyle = COLORS.ui;
                this.ctx.fillRect(barX, barY, barWidth * progress, barHeight);
                
                this.ctx.strokeStyle = COLORS.text;
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = '12px monospace';
                this.ctx.textAlign = 'right';
                this.ctx.fillText(`Score: ${this.score}`, GAME_WIDTH - 20, barY - 5);
            }
            
            renderPauseOverlay() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                
                this.ctx.fillStyle = COLORS.ui;
                this.ctx.font = 'bold 32px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('PAUSED', GAME_WIDTH / 2, GAME_HEIGHT / 2);
                
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = '16px monospace';
                this.ctx.fillText('Press SPACE to Resume', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 40);
            }
            
            renderHitPauseOverlay() {
                this.ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                
                this.ctx.fillStyle = COLORS.player;
                this.ctx.font = 'bold 36px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('HIT!', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 40);
                
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = '24px monospace';
                this.ctx.fillText(`Lives Remaining: ${this.lives}`, GAME_WIDTH / 2, GAME_HEIGHT / 2);
                
                this.ctx.fillStyle = COLORS.ui;
                this.ctx.font = 'bold 18px monospace';
                this.ctx.fillText('Press SPACE to Continue', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 50);
                
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = '16px monospace';
                this.ctx.fillText('Lives: ', GAME_WIDTH / 2 - 40, GAME_HEIGHT / 2 + 80);
                for (let i = 0; i < 3; i++) {
                    this.ctx.fillStyle = i < this.lives ? COLORS.player : COLORS.shadow;
                    this.ctx.fillText('‚ô•', GAME_WIDTH / 2 - 20 + i * 20, GAME_HEIGHT / 2 + 80);
                }
            }
            
            renderGameOverScreen() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                
                this.ctx.fillStyle = COLORS.player;
                this.ctx.font = 'bold 36px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('GAME OVER', GAME_WIDTH / 2, 200);
                
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = '18px monospace';
                this.ctx.fillText(`Final Score: ${this.score}`, GAME_WIDTH / 2, 250);
                this.ctx.fillText(`Highest Level: ${this.difficultyLevel}`, GAME_WIDTH / 2, 280);
                
                const accuracy = this.totalCarrots > 0 ? Math.round((this.caughtCarrots / this.totalCarrots) * 100) : 0;
                this.ctx.fillText(`Accuracy: ${accuracy}%`, GAME_WIDTH / 2, 310);
                this.ctx.fillText(`Max Combo: ${this.maxCombo}`, GAME_WIDTH / 2, 340);
                
                if (this.bestScore > 0) {
                    this.ctx.fillStyle = COLORS.carrot;
                    this.ctx.fillText(`Best Score: ${this.bestScore}`, GAME_WIDTH / 2, 380);
                }
                
                this.ctx.fillStyle = COLORS.ui;
                this.ctx.font = 'bold 16px monospace';
                this.ctx.fillText('Press SPACE to Play Again', GAME_WIDTH / 2, 450);
                
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = '12px monospace';
                this.ctx.fillText('M: Mute | C: CRT Effect', GAME_WIDTH / 2, 500);
            }
            
            gameLoop() {
                const now = Date.now();
                this.deltaTime = now - this.lastFrameTime;
                this.lastFrameTime = now;
                
                this.update(this.deltaTime);
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Initialize game when page loads
        window.addEventListener('load', () => {
            console.log('Initializing Bunny Bag Game...');
            try {
                const game = new BunnyBagGame();
                console.log('Game initialized successfully');
            } catch (error) {
                console.error('Game initialization failed:', error);
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = `Error: ${error.message}`;
            }
        });
    </script>
</body>
</html>
