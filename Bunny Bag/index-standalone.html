<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bunny Bag — Carrot Catcher</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #eee;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            border: 4px solid #4a4a6a;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            background: #1a1a2e;
        }
        
        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            border-radius: 4px;
        }
        
        #crtOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: linear-gradient(transparent 50%, rgba(0, 255, 0, 0.03) 50%);
            background-size: 100% 4px;
            opacity: 0;
            transition: opacity 0.3s;
            border-radius: 4px;
        }
        
        #crtOverlay.active {
            opacity: 1;
        }
        
        .controls {
            position: absolute;
            bottom: -60px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 12px;
            color: #888;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 4px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff00;
            font-size: 18px;
            font-family: 'Courier New', monospace;
        }

        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            text-align: center;
            max-width: 300px;
        }

        @media (max-width: 900px) {
            body {
                padding: 10px;
            }
            
            #gameContainer {
                max-width: 100%;
                max-height: 100vh;
            }
            
            #gameCanvas {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="crtOverlay"></div>
        <div class="controls">
            ← → Move | ↑ Jump | Space: Start/Pause | M: Mute | C: Toggle CRT
        </div>
        <div id="loading" class="loading" style="display: none;">
            Loading Game...
        </div>
        <div id="error" class="error" style="display: none;">
            Failed to load game. Please refresh the page.
        </div>
    </div>
    
    <script>
        // Inline game code to avoid module issues
        console.log('Loading Bunny Bag Game...');
        
        // Game Constants
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;
        const PLAYER_WIDTH = 32;
        const PLAYER_HEIGHT = 32;
        const CARROT_SIZE = 16;
        const BAG_WIDTH = 40;
        const BAG_HEIGHT = 20;
        const GROUND_Y = GAME_HEIGHT - 20;
        const JUMP_POWER = 14;
        const GRAVITY = 0.5;
        const OBSTACLE_WIDTH = 24;
        const OBSTACLE_HEIGHT = 32;

        // Color Palette
        const COLORS = {
            background: '#1a1a2e',
            player: '#ff6b6b',
            carrot: '#ffa500',
            bag: '#8b4513',
            text: '#ffffff',
            ui: '#00ff00',
            shadow: '#000000',
            ground: '#4a4a6a',
            obstacle: '#8B4513',
            obstacleTop: '#A0522D',
            bunnyPink: '#ffb6c1',
            bunnyNose: '#ff69b4'
        };

        // Game States
        const GAME_STATES = {
            TITLE: 'title',
            PLAYING: 'playing',
            PAUSED: 'paused',
            HIT_PAUSE: 'hitPause',
            GAME_OVER: 'gameOver'
        };

        // Score-based progression thresholds
        const SCORE_THRESHOLDS = {
            OBSTACLES_START: 100,
            SPEED_INCREASE: 200,
            MULTI_SPAWN_START: 300,
            RAPID_INCREASE: 500
        };

        // Main Game Class
        class BunnyBagGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.crtOverlay = document.getElementById('crtOverlay');
                
                // Game State
                this.state = GAME_STATES.TITLE;
                this.score = 0;
                this.lives = 3;
                this.difficultyLevel = 1;
                this.difficultyProgress = 0;
                this.caughtCarrots = 0;
                this.totalCarrots = 0;
                this.combo = 0;
                this.maxCombo = 0;
                this.bestScore = parseInt(localStorage.getItem('bunnyBagBestScore') || '0');
                
                // Hit pause state
                this.hitPauseTime = 0;
                
                // Player
                this.player = {
                    x: GAME_WIDTH / 2 - PLAYER_WIDTH / 2,
                    y: GROUND_Y - PLAYER_HEIGHT,
                    width: PLAYER_WIDTH,
                    height: PLAYER_HEIGHT,
                    speed: 4,
                    direction: 0,
                    velocityY: 0,
                    onGround: true,
                    canJump: true
                };
                
                // Game Objects
                this.carrots = [];
                this.obstacles = [];
                this.particles = [];
                
                // Timing
                this.lastSpawnTime = 0;
                this.lastObstacleSpawnTime = 0;
                this.gameTime = 0;
                this.lastFrameTime = 0;
                this.deltaTime = 0;
                
                // Settings
                this.muted = false;
                this.crtEnabled = false;
                
                // Input
                this.keys = {};
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.gameLoop();
            }
            
            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    this.handleKeyPress(e);
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            handleKeyPress(e) {
                switch (e.code) {
                    case 'Space':
                        e.preventDefault();
                        this.handleSpaceKey();
                        break;
                    case 'KeyM':
                        this.toggleMute();
                        break;
                    case 'KeyC':
                        this.toggleCRT();
                        break;
                    case 'ArrowUp':
                    case 'KeyW':
                        e.preventDefault();
                        this.handleJump();
                        break;
                }
            }
            
            handleSpaceKey() {
                switch (this.state) {
                    case GAME_STATES.TITLE:
                        this.startGame();
                        break;
                    case GAME_STATES.PLAYING:
                        this.pauseGame();
                        break;
                    case GAME_STATES.PAUSED:
                        this.resumeGame();
                        break;
                    case GAME_STATES.HIT_PAUSE:
                        this.resumeFromHit();
                        break;
                    case GAME_STATES.GAME_OVER:
                        this.restartGame();
                        break;
                }
            }
            
            toggleMute() {
                this.muted = !this.muted;
            }
            
            toggleCRT() {
                this.crtEnabled = !this.crtEnabled;
                this.crtOverlay.classList.toggle('active', this.crtEnabled);
            }
            
            handleJump() {
                if (this.state === GAME_STATES.PLAYING && this.player.canJump && this.player.onGround) {
                    this.player.velocityY = -JUMP_POWER;
                    this.player.onGround = false;
                    this.player.canJump = false;
                }
            }
            
            startGame() {
                this.state = GAME_STATES.PLAYING;
                this.resetGame();
            }
            
            pauseGame() {
                this.state = GAME_STATES.PAUSED;
            }
            
            resumeGame() {
                this.state = GAME_STATES.PLAYING;
            }
            
            resumeFromHit() {
                this.state = GAME_STATES.PLAYING;
                this.hitPauseTime = 0;
            }
            
            restartGame() {
                this.state = GAME_STATES.TITLE;
                this.resetGame();
            }
            
            resetGame() {
                this.score = 0;
                this.lives = 3;
                this.difficultyProgress = 0;
                this.caughtCarrots = 0;
                this.totalCarrots = 0;
                this.combo = 0;
                this.maxCombo = 0;
                this.carrots = [];
                this.obstacles = [];
                this.particles = [];
                this.player.x = GAME_WIDTH / 2 - PLAYER_WIDTH / 2;
                this.player.y = GROUND_Y - PLAYER_HEIGHT;
                this.player.velocityY = 0;
                this.player.onGround = true;
                this.player.canJump = true;
                this.lastSpawnTime = 0;
                this.lastObstacleSpawnTime = 0;
                this.gameTime = 0;
                this.hitPauseTime = 0;
            }
            
            gameOver() {
                this.state = GAME_STATES.GAME_OVER;
                
                if (this.score > this.bestScore) {
                    this.bestScore = this.score;
                    localStorage.setItem('bunnyBagBestScore', this.bestScore.toString());
                }
            }
            
            update(deltaTime) {
                if (this.state !== GAME_STATES.PLAYING) return;
                
                this.gameTime += deltaTime;
                
                this.updatePlayer(deltaTime);
                this.updateCarrots(deltaTime);
                this.updateObstacles(deltaTime);
                this.updateParticles(deltaTime);
                this.spawnCarrots();
                this.spawnObstacles();
                this.updateDifficultyProgression();
            }
            
            updatePlayer(deltaTime) {
                if (this.keys['ArrowLeft'] || this.keys['KeyA']) {
                    this.player.direction = -1;
                } else if (this.keys['ArrowRight'] || this.keys['KeyD']) {
                    this.player.direction = 1;
                } else {
                    this.player.direction = 0;
                }
                
                this.player.x += this.player.direction * this.player.speed;
                
                if (!this.player.onGround) {
                    this.player.velocityY += GRAVITY;
                    this.player.y += this.player.velocityY;
                    
                    if (this.player.y >= GROUND_Y - this.player.height) {
                        this.player.y = GROUND_Y - this.player.height;
                        this.player.velocityY = 0;
                        this.player.onGround = true;
                        this.player.canJump = true;
                    }
                }
                
                this.player.x = Math.max(0, Math.min(GAME_WIDTH - this.player.width, this.player.x));
            }
            
            updateCarrots(deltaTime) {
                const config = this.getDifficultyConfig();
                
                for (let i = this.carrots.length - 1; i >= 0; i--) {
                    const carrot = this.carrots[i];
                    carrot.y += carrot.speed * deltaTime * 0.1;
                    
                    if (this.checkCarrotCollision(carrot)) {
                        this.catchCarrot(carrot, i);
                        continue;
                    }
                    
                    if (carrot.y > GAME_HEIGHT - 20) {
                        this.groundCarrot(carrot, i);
                    }
                }
            }
            
            updateObstacles(deltaTime) {
                for (let i = this.obstacles.length - 1; i >= 0; i--) {
                    const obstacle = this.obstacles[i];
                    obstacle.x -= obstacle.speed;
                    
                    if (this.checkObstacleCollision(obstacle)) {
                        this.hitObstacle(obstacle, i);
                        continue;
                    }
                    
                    if (obstacle.x + obstacle.width < 0) {
                        this.obstacles.splice(i, 1);
                    }
                }
            }
            
            updateParticles(deltaTime) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.x += particle.vx * deltaTime * 0.1;
                    particle.y += particle.vy * deltaTime * 0.1;
                    particle.life -= deltaTime;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            spawnCarrots() {
                const config = this.getDifficultyConfig();
                const now = Date.now();
                
                if (now - this.lastSpawnTime > config.spawnInterval) {
                    this.createCarrot();
                    
                    if (Math.random() < config.multiSpawn) {
                        setTimeout(() => this.createCarrot(), 200);
                        if (Math.random() < config.multiSpawn * 0.5) {
                            setTimeout(() => this.createCarrot(), 400);
                        }
                    }
                    
                    this.lastSpawnTime = now;
                }
            }
            
            spawnObstacles() {
                const config = this.getDifficultyConfig();
                
                if (!config.obstacles) return;
                
                const now = Date.now();
                const obstacleSpawnInterval = 4000;
                
                if (now - this.lastObstacleSpawnTime > obstacleSpawnInterval) {
                    if (Math.random() < config.obstacleSpawn) {
                        this.createObstacle();
                        this.lastObstacleSpawnTime = now;
                    }
                }
            }
            
            createCarrot() {
                const config = this.getDifficultyConfig();
                
                let x;
                if (this.score < 200) {
                    x = Math.random() * (GAME_WIDTH - CARROT_SIZE);
                } else if (this.score < 500) {
                    if (this.carrots.length > 0) {
                        const lastCarrot = this.carrots[this.carrots.length - 1];
                        const offset = (Math.random() - 0.5) * 150;
                        x = Math.max(0, Math.min(GAME_WIDTH - CARROT_SIZE, lastCarrot.x + offset));
                    } else {
                        x = Math.random() * (GAME_WIDTH - CARROT_SIZE);
                    }
                } else {
                    if (this.carrots.length > 0) {
                        const lastCarrot = this.carrots[this.carrots.length - 1];
                        const offset = (Math.random() - 0.5) * 200;
                        x = Math.max(0, Math.min(GAME_WIDTH - CARROT_SIZE, lastCarrot.x + offset));
                    } else {
                        x = Math.random() * (GAME_WIDTH - CARROT_SIZE);
                    }
                }
                
                const carrot = {
                    x: x,
                    y: -CARROT_SIZE,
                    width: CARROT_SIZE,
                    height: CARROT_SIZE,
                    speed: config.fallSpeed + (Math.random() - 0.5) * 0.3,
                    rotation: 0
                };
                
                this.carrots.push(carrot);
                this.totalCarrots++;
            }
            
            createObstacle() {
                const config = this.getDifficultyConfig();
                const obstacle = {
                    x: GAME_WIDTH,
                    y: GROUND_Y - OBSTACLE_HEIGHT,
                    width: OBSTACLE_WIDTH,
                    height: OBSTACLE_HEIGHT,
                    speed: config.obstacleSpeed,
                    type: Math.random() < 0.7 ? 'log' : 'rock'
                };
                
                this.obstacles.push(obstacle);
            }
            
            checkCarrotCollision(carrot) {
                const bagX = this.player.x + (this.player.width - BAG_WIDTH) / 2;
                const bagY = this.player.y - BAG_HEIGHT;
                
                return carrot.x < bagX + BAG_WIDTH &&
                       carrot.x + carrot.width > bagX &&
                       carrot.y < bagY + BAG_HEIGHT &&
                       carrot.y + carrot.height > bagY;
            }
            
            checkObstacleCollision(obstacle) {
                return this.player.x < obstacle.x + obstacle.width &&
                       this.player.x + this.player.width > obstacle.x &&
                       this.player.y < obstacle.y + obstacle.height &&
                       this.player.y + this.player.height > obstacle.y;
            }
            
            catchCarrot(carrot, index) {
                this.carrots.splice(index, 1);
                
                this.score += 10;
                this.caughtCarrots++;
                this.combo++;
                this.maxCombo = Math.max(this.maxCombo, this.combo);
                
                this.createCatchParticles(carrot.x + carrot.width / 2, carrot.y + carrot.height / 2);
            }
            
            groundCarrot(carrot, index) {
                this.carrots.splice(index, 1);
                this.combo = 0;
                this.createGroundParticles(carrot.x + carrot.width / 2, carrot.y + carrot.height / 2);
            }
            
            hitObstacle(obstacle, index) {
                this.obstacles.splice(index, 1);
                this.combo = 0;
                this.lives--;
                
                this.createHitParticles(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2);
                
                this.state = GAME_STATES.HIT_PAUSE;
                this.hitPauseTime = Date.now();
                
                if (this.lives <= 0) {
                    this.gameOver();
                }
            }
            
            getDifficultyConfig() {
                const config = {
                    spawnInterval: 2000,
                    fallSpeed: 2,
                    multiSpawn: 0,
                    obstacles: false,
                    obstacleSpawn: 0,
                    obstacleSpeed: 2.5
                };
                
                const score = this.score;
                
                if (score >= SCORE_THRESHOLDS.OBSTACLES_START) {
                    config.obstacles = true;
                    config.obstacleSpawn = Math.min(0.3, 0.05 + (score - SCORE_THRESHOLDS.OBSTACLES_START) * 0.001);
                    config.obstacleSpeed = Math.min(4.5, 2.5 + (score - SCORE_THRESHOLDS.OBSTACLES_START) * 0.01);
                }
                
                if (score >= SCORE_THRESHOLDS.SPEED_INCREASE) {
                    const speedMultiplier = 1 + (score - SCORE_THRESHOLDS.SPEED_INCREASE) * 0.01;
                    config.fallSpeed = Math.min(8, 2 * speedMultiplier);
                    config.spawnInterval = Math.max(300, 2000 / speedMultiplier);
                }
                
                if (score >= SCORE_THRESHOLDS.MULTI_SPAWN_START) {
                    config.multiSpawn = Math.min(0.5, (score - SCORE_THRESHOLDS.MULTI_SPAWN_START) * 0.003);
                }
                
                if (score >= SCORE_THRESHOLDS.RAPID_INCREASE) {
                    const rapidMultiplier = 1 + (score - SCORE_THRESHOLDS.RAPID_INCREASE) * 0.01;
                    config.fallSpeed = Math.min(12, config.fallSpeed * rapidMultiplier);
                    config.spawnInterval = Math.max(200, config.spawnInterval / rapidMultiplier);
                    config.obstacleSpeed = Math.min(5.5, config.obstacleSpeed * rapidMultiplier);
                    config.obstacleSpawn = Math.min(0.4, config.obstacleSpawn * rapidMultiplier);
                }
                
                return config;
            }
            
            updateDifficultyProgression() {
                const newLevel = Math.floor(this.score / 25) + 1;
                if (newLevel > this.difficultyLevel) {
                    this.difficultyLevel = newLevel;
                    this.createStageUpParticles();
                }
            }
            
            createCatchParticles(x, y) {
                for (let i = 0; i < 5; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4 - 2,
                        life: 1000,
                        color: COLORS.carrot
                    });
                }
            }
            
            createGroundParticles(x, y) {
                for (let i = 0; i < 3; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: 500,
                        color: COLORS.ground
                    });
                }
            }
            
            createHitParticles(x, y) {
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6 - 3,
                        life: 800,
                        color: COLORS.shadow
                    });
                }
            }
            
            createStageUpParticles() {
                for (let i = 0; i < 20; i++) {
                    this.particles.push({
                        x: GAME_WIDTH / 2,
                        y: GAME_HEIGHT / 2,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 2000,
                        color: COLORS.ui
                    });
                }
            }
            
            render() {
                try {
                    this.ctx.fillStyle = COLORS.background;
                    this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                    
                    this.ctx.fillStyle = COLORS.ground;
                    this.ctx.fillRect(0, GAME_HEIGHT - 20, GAME_WIDTH, 20);
                    
                    switch (this.state) {
                        case GAME_STATES.TITLE:
                            this.renderTitleScreen();
                            break;
                        case GAME_STATES.PLAYING:
                        case GAME_STATES.PAUSED:
                        case GAME_STATES.HIT_PAUSE:
                            this.renderGameplay();
                            if (this.state === GAME_STATES.PAUSED) {
                                this.renderPauseOverlay();
                            } else if (this.state === GAME_STATES.HIT_PAUSE) {
                                this.renderHitPauseOverlay();
                            }
                            break;
                        case GAME_STATES.GAME_OVER:
                            this.renderGameplay();
                            this.renderGameOverScreen();
                            break;
                    }
                } catch (error) {
                    console.error('Render error:', error);
                    // Draw error message on canvas
                    this.ctx.fillStyle = '#ff0000';
                    this.ctx.font = '16px monospace';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('Render Error: ' + error.message, GAME_WIDTH / 2, GAME_HEIGHT / 2);
                }
            }
            
            renderTitleScreen() {
                this.ctx.fillStyle = COLORS.ui;
                this.ctx.font = 'bold 48px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('BUNNY BAG', GAME_WIDTH / 2, 150);
                
                this.ctx.font = 'bold 24px monospace';
                this.ctx.fillText('Carrot Catcher', GAME_WIDTH / 2, 190);
                
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = '16px monospace';
                this.ctx.fillText('Pure Skill Progression • No Currencies • No IAP', GAME_WIDTH / 2, 250);
                
                this.ctx.font = '14px monospace';
                this.ctx.fillText('Catch falling carrots with your bag!', GAME_WIDTH / 2, 300);
                this.ctx.fillText('Each carrot = 10 points!', GAME_WIDTH / 2, 320);
                this.ctx.fillText('Carrots fall straight down - timing is key!', GAME_WIDTH / 2, 340);
                this.ctx.fillText('Only lose lives when hit by obstacles!', GAME_WIDTH / 2, 360);
                
                this.ctx.fillStyle = COLORS.ui;
                this.ctx.font = 'bold 16px monospace';
                this.ctx.fillText('Press SPACE to Start', GAME_WIDTH / 2, 420);
                
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = '12px monospace';
                this.ctx.fillText('← → Move | ↑ Jump | M: Mute | C: CRT Effect', GAME_WIDTH / 2, 450);
                
                if (this.bestScore > 0) {
                    this.ctx.fillStyle = COLORS.carrot;
                    this.ctx.font = '14px monospace';
                    this.ctx.fillText(`Best Score: ${this.bestScore}`, GAME_WIDTH / 2, 480);
                }
            }
            
            renderGameplay() {
                this.obstacles.forEach(obstacle => {
                    this.renderObstacle(obstacle);
                });
                
                this.carrots.forEach(carrot => {
                    this.renderCarrot(carrot);
                });
                
                this.renderPlayer();
                
                this.particles.forEach(particle => {
                    this.ctx.fillStyle = particle.color;
                    this.ctx.fillRect(particle.x, particle.y, 2, 2);
                });
                
                this.renderUI();
            }
            
            renderCarrot(carrot) {
                // Enhanced carrot rendering with your custom design
                this.renderCarrotBody(carrot);
                this.renderCarrotTop(carrot);
            }
            
            renderCarrotBody(carrot) {
                const x = carrot.x;
                const y = carrot.y;
                
                // Base orange color
                this.ctx.fillStyle = '#FF8C00';
                this.ctx.fillRect(x + 2, y + 8, 12, 8);
                
                // Darker orange shading
                this.ctx.fillStyle = '#FF7F00';
                this.ctx.fillRect(x + 3, y + 9, 10, 6);
                this.ctx.fillRect(x + 4, y + 10, 8, 4);
                
                // Lighter orange highlights
                this.ctx.fillStyle = '#FFA500';
                this.ctx.fillRect(x + 1, y + 8, 2, 8);
                this.ctx.fillRect(x + 13, y + 8, 2, 8);
                
                // Carrot tip
                this.ctx.fillStyle = '#FF8C00';
                this.ctx.fillRect(x + 6, y + 16, 4, 2);
                this.ctx.fillRect(x + 7, y + 18, 2, 1);
            }
            
            renderCarrotTop(carrot) {
                const x = carrot.x;
                const y = carrot.y;
                
                // Main green leafy top
                this.ctx.fillStyle = '#32CD32';
                this.ctx.fillRect(x + 4, y + 2, 8, 6);
                
                // Darker green for depth
                this.ctx.fillStyle = '#228B22';
                this.ctx.fillRect(x + 5, y + 3, 6, 4);
                
                // Individual leaf structures
                this.ctx.fillStyle = '#32CD32';
                // Left leaf
                this.ctx.fillRect(x + 2, y + 1, 3, 4);
                this.ctx.fillRect(x + 1, y + 2, 2, 2);
                
                // Right leaf
                this.ctx.fillRect(x + 11, y + 1, 3, 4);
                this.ctx.fillRect(x + 13, y + 2, 2, 2);
                
                // Center leaves
                this.ctx.fillRect(x + 5, y, 2, 3);
                this.ctx.fillRect(x + 9, y, 2, 3);
                
                // Small tendrils
                this.ctx.fillStyle = '#90EE90';
                this.ctx.fillRect(x + 6, y - 1, 1, 2);
                this.ctx.fillRect(x + 9, y - 1, 1, 2);
                this.ctx.fillRect(x + 7, y - 2, 1, 1);
                this.ctx.fillRect(x + 8, y - 2, 1, 1);
            }
            
            renderPlayer() {
                // Draw bag
                this.ctx.fillStyle = COLORS.bag;
                const bagX = this.player.x + (this.player.width - BAG_WIDTH) / 2;
                const bagY = this.player.y - BAG_HEIGHT;
                this.ctx.fillRect(bagX, bagY, BAG_WIDTH, BAG_HEIGHT);
                
                this.ctx.fillStyle = COLORS.shadow;
                this.ctx.fillRect(bagX + 2, bagY + 2, BAG_WIDTH - 4, BAG_HEIGHT - 4);
                
                this.ctx.fillStyle = COLORS.shadow;
                this.ctx.fillRect(bagX + 4, bagY - 4, 2, 4);
                this.ctx.fillRect(bagX + BAG_WIDTH - 6, bagY - 4, 2, 4);
                
                // Draw rabbit body
                this.ctx.fillStyle = COLORS.player;
                this.ctx.fillRect(this.player.x + 4, this.player.y + 8, 24, 24);
                
                // Draw rabbit head
                this.ctx.fillStyle = COLORS.player;
                this.ctx.fillRect(this.player.x + 6, this.player.y + 2, 20, 16);
                
                // Draw ears
                this.ctx.fillStyle = COLORS.player;
                this.ctx.fillRect(this.player.x + 8, this.player.y - 6, 3, 8);
                this.ctx.fillRect(this.player.x + 21, this.player.y - 6, 3, 8);
                
                // Draw inner ears
                this.ctx.fillStyle = COLORS.bunnyPink;
                this.ctx.fillRect(this.player.x + 9, this.player.y - 4, 1, 4);
                this.ctx.fillRect(this.player.x + 22, this.player.y - 4, 1, 4);
                
                // Draw eyes
                this.ctx.fillStyle = COLORS.shadow;
                this.ctx.fillRect(this.player.x + 10, this.player.y + 6, 2, 2);
                this.ctx.fillRect(this.player.x + 20, this.player.y + 6, 2, 2);
                
                // Draw eye highlights
                this.ctx.fillStyle = COLORS.text;
                this.ctx.fillRect(this.player.x + 11, this.player.y + 7, 1, 1);
                this.ctx.fillRect(this.player.x + 21, this.player.y + 7, 1, 1);
                
                // Draw nose
                this.ctx.fillStyle = COLORS.bunnyNose;
                this.ctx.fillRect(this.player.x + 15, this.player.y + 10, 2, 1);
                
                // Draw mouth
                this.ctx.fillStyle = COLORS.shadow;
                this.ctx.fillRect(this.player.x + 14, this.player.y + 12, 4, 1);
                
                // Draw whiskers
                this.ctx.fillStyle = COLORS.shadow;
                this.ctx.fillRect(this.player.x + 8, this.player.y + 11, 6, 1);
                this.ctx.fillRect(this.player.x + 18, this.player.y + 11, 6, 1);
                
                // Draw arms
                this.ctx.fillStyle = COLORS.player;
                this.ctx.fillRect(this.player.x + 2, this.player.y + 12, 4, 8);
                this.ctx.fillRect(this.player.x + 26, this.player.y + 12, 4, 8);
                
                // Draw legs
                this.ctx.fillStyle = COLORS.player;
                this.ctx.fillRect(this.player.x + 8, this.player.y + 28, 6, 4);
                this.ctx.fillRect(this.player.x + 18, this.player.y + 28, 6, 4);
                
                // Draw feet
                this.ctx.fillStyle = COLORS.bunnyPink;
                this.ctx.fillRect(this.player.x + 7, this.player.y + 30, 8, 2);
                this.ctx.fillRect(this.player.x + 17, this.player.y + 30, 8, 2);
                
                // Draw tail
                this.ctx.fillStyle = COLORS.bunnyPink;
                this.ctx.fillRect(this.player.x + 14, this.player.y + 26, 4, 4);
            }
            
            renderObstacle(obstacle) {
                if (this.player) {
                    const distanceToPlayer = obstacle.x - (this.player.x + this.player.width);
                    if (distanceToPlayer < 200 && distanceToPlayer > 0) {
                        this.ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                        this.ctx.fillRect(obstacle.x - 4, obstacle.y - 4, obstacle.width + 8, obstacle.height + 8);
                    }
                }
                
                if (obstacle.type === 'log') {
                    this.ctx.fillStyle = COLORS.obstacle;
                    this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    
                    this.ctx.fillStyle = COLORS.obstacleTop;
                    this.ctx.fillRect(obstacle.x + 2, obstacle.y + 2, obstacle.width - 4, 4);
                    this.ctx.fillRect(obstacle.x + 2, obstacle.y + 8, obstacle.width - 4, 2);
                    this.ctx.fillRect(obstacle.x + 2, obstacle.y + 14, obstacle.width - 4, 2);
                } else if (obstacle.type === 'rock') {
                    this.ctx.fillStyle = COLORS.shadow;
                    this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    
                    this.ctx.fillStyle = COLORS.obstacle;
                    this.ctx.fillRect(obstacle.x + 2, obstacle.y + 2, obstacle.width - 4, obstacle.height - 4);
                    
                    this.ctx.fillStyle = COLORS.obstacleTop;
                    this.ctx.fillRect(obstacle.x + 4, obstacle.y + 4, 4, 4);
                    this.ctx.fillRect(obstacle.x + 12, obstacle.y + 8, 4, 4);
                    this.ctx.fillRect(obstacle.x + 8, obstacle.y + 16, 4, 4);
                }
            }
            
            renderUI() {
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = 'bold 16px monospace';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`Score: ${this.score}`, 20, 30);
                
                this.ctx.fillText(`Lives: `, 20, 55);
                for (let i = 0; i < 3; i++) {
                    this.ctx.fillStyle = i < this.lives ? COLORS.player : COLORS.shadow;
                    this.ctx.fillText('♥', 80 + i * 20, 55);
                }
                
                this.ctx.fillStyle = COLORS.ui;
                this.ctx.fillText(`Level: ${this.difficultyLevel}`, 20, 80);
                
                const accuracy = this.totalCarrots > 0 ? Math.round((this.caughtCarrots / this.totalCarrots) * 100) : 0;
                this.ctx.fillText(`Accuracy: ${accuracy}%`, 20, 105);
                
                if (this.combo > 0) {
                    this.ctx.fillStyle = COLORS.carrot;
                    this.ctx.fillText(`Combo: ${this.combo}`, 20, 130);
                }
                
                this.renderProgressBar();
            }
            
            renderProgressBar() {
                const barWidth = 200;
                const barHeight = 8;
                const barX = GAME_WIDTH - barWidth - 20;
                const barY = 20;
                
                this.ctx.fillStyle = COLORS.shadow;
                this.ctx.fillRect(barX, barY, barWidth, barHeight);
                
                const progress = Math.min(1, this.score / 1000);
                this.ctx.fillStyle = COLORS.ui;
                this.ctx.fillRect(barX, barY, barWidth * progress, barHeight);
                
                this.ctx.strokeStyle = COLORS.text;
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = '12px monospace';
                this.ctx.textAlign = 'right';
                this.ctx.fillText(`Score: ${this.score}`, GAME_WIDTH - 20, barY - 5);
            }
            
            renderPauseOverlay() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                
                this.ctx.fillStyle = COLORS.ui;
                this.ctx.font = 'bold 32px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('PAUSED', GAME_WIDTH / 2, GAME_HEIGHT / 2);
                
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = '16px monospace';
                this.ctx.fillText('Press SPACE to Resume', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 40);
            }
            
            renderHitPauseOverlay() {
                this.ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                
                this.ctx.fillStyle = COLORS.player;
                this.ctx.font = 'bold 36px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('HIT!', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 40);
                
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = '24px monospace';
                this.ctx.fillText(`Lives Remaining: ${this.lives}`, GAME_WIDTH / 2, GAME_HEIGHT / 2);
                
                this.ctx.fillStyle = COLORS.ui;
                this.ctx.font = 'bold 18px monospace';
                this.ctx.fillText('Press SPACE to Continue', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 50);
                
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = '16px monospace';
                this.ctx.fillText('Lives: ', GAME_WIDTH / 2 - 40, GAME_HEIGHT / 2 + 80);
                for (let i = 0; i < 3; i++) {
                    this.ctx.fillStyle = i < this.lives ? COLORS.player : COLORS.shadow;
                    this.ctx.fillText('♥', GAME_WIDTH / 2 - 20 + i * 20, GAME_HEIGHT / 2 + 80);
                }
            }
            
            renderGameOverScreen() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                
                this.ctx.fillStyle = COLORS.player;
                this.ctx.font = 'bold 36px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('GAME OVER', GAME_WIDTH / 2, 200);
                
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = '18px monospace';
                this.ctx.fillText(`Final Score: ${this.score}`, GAME_WIDTH / 2, 250);
                this.ctx.fillText(`Highest Level: ${this.difficultyLevel}`, GAME_WIDTH / 2, 280);
                
                const accuracy = this.totalCarrots > 0 ? Math.round((this.caughtCarrots / this.totalCarrots) * 100) : 0;
                this.ctx.fillText(`Accuracy: ${accuracy}%`, GAME_WIDTH / 2, 310);
                this.ctx.fillText(`Max Combo: ${this.maxCombo}`, GAME_WIDTH / 2, 340);
                
                if (this.bestScore > 0) {
                    this.ctx.fillStyle = COLORS.carrot;
                    this.ctx.fillText(`Best Score: ${this.bestScore}`, GAME_WIDTH / 2, 380);
                }
                
                this.ctx.fillStyle = COLORS.ui;
                this.ctx.font = 'bold 16px monospace';
                this.ctx.fillText('Press SPACE to Play Again', GAME_WIDTH / 2, 450);
                
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = '12px monospace';
                this.ctx.fillText('M: Mute | C: CRT Effect', GAME_WIDTH / 2, 500);
            }
            
            gameLoop() {
                const now = Date.now();
                this.deltaTime = now - this.lastFrameTime;
                this.lastFrameTime = now;
                
                this.update(this.deltaTime);
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Initialize game when page loads
        window.addEventListener('load', () => {
            console.log('Initializing Bunny Bag Game...');
            try {
                const game = new BunnyBagGame();
                console.log('Game initialized successfully');
            } catch (error) {
                console.error('Game initialization failed:', error);
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = `Error: ${error.message}`;
            }
        });
    </script>
</body>
</html>
